{"componentChunkName":"component---src-templates-blog-post-js","path":"/programming-basics/index0609/","result":{"data":{"site":{"siteMetadata":{"title":"오늘도 앞으로"}},"markdownRemark":{"id":"661b6951-f5a7-5815-82e2-ca1d1430815e","excerpt":"상속(inheritance…","html":"<ul>\n<li>\n<p>상속(inheritance)</p>\n<p>상속은 객체 지향 프로그래밍에서 사용되는 중요한 개념 중 하나입니다. 상속은 부모 클래스의 속성과 메소드를 자식 클래스가 물려받는 것을 의미합니다.</p>\n<ul>\n<li>자손은 부모의 모든 멤버를 상속받습니다. (생성자와 초기화블럭 제외)</li>\n<li>자손의 멤버 수는 부모의 멤버 수보다 적을 수 없습니다.</li>\n</ul>\n<p>이를테면, 부모 클래스가 '동물'이라면, 자식 클래스는 '개', '고양이', '코끼리' 등이 될 수 있습니다. 자식 클래스는 부모 클래스의 속성과 메소드를 상속받아서 자신만의 속성과 메소드를 추가할 수 있습니다.</p>\n<p>상속의 장점은 코드의 재사용성을 높일 수 있다는 것입니다. 이미 구현된 코드를 그대로 사용할 수 있기 때문에 시간과 비용을 절약할 수 있습니다. 또한, 상속을 이용하면 코드의 유지보수가 쉬워집니다. 부모 클래스의 속성과 메소드를 수정하면, 자식 클래스에서도 자동으로 반영되기 때문입니다.</p>\n<p>하지만, 상속이 항상 좋은 것은 아닙니다. 클래스 간의 관계가 복잡해지면 코드를 이해하기 어렵고 유지보수하기 어려워질 수 있습니다. 또한, 부모 클래스의 변경이 자식 클래스에 영향을 미칠 수 있기 때문에 신중하게 사용해야 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> 자손클래스 <span class=\"token keyword\">extends</span> 부모클래스 <span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n  <aside>\n  ➕ 모든 클래스의 부모 클래스를 따라 올라가면 꼭대기에는 오브젝트가 있습니다.\n  </aside>\n<ul>\n<li>\n<p>헤즈어 관계(<code class=\"language-text\">has-a</code>관계)</p>\n<p>헤즈어 관계는 객체 지향 프로그래밍에서 사용되는 또 다른 개념입니다. 이는 클래스 간의 관계를 나타내는 것으로, 한 클래스가 다른 클래스를 포함하는 것을 의미합니다. 포함되는 클래스를 '부분(part)'이라고 하고, 포함하는 클래스를 '전체(whole)'이라고 합니다.</p>\n<p>예를 들어, 자동차 클래스는 엔진 클래스를 포함할 수 있습니다. 이때 자동차는 엔진의 부분, 엔진은 자동차의 전체입니다. 부분 클래스는 전체 클래스의 속성과 메소드를 사용할 수 있습니다.</p>\n<p>헤즈어 관계 역시 코드의 재사용성을 높일 수 있습니다. 부분 클래스가 전체 클래스의 속성과 메소드를 상속받기 때문입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> 전체클래스 <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">class</span> 부분클래스 <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// ...</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ul>\n</li>\n<li>\n<p>오버라이딩(overriding)</p>\n<p>오버라이딩은 자식 클래스에서 부모 클래스의 메소드를 재정의하는 것을 의미합니다. 부모 클래스에 있는 메소드와 같은 이름, 매개변수, 반환타입으로 자식 클래스에서 메소드를 다시 정의하면, 부모 클래스의 메소드 대신 자식 클래스의 메소드가 실행됩니다.</p>\n<ul>\n<li>이름, 반환형, 매개변수는 변경할 수 없습니다.</li>\n</ul>\n<p>오버라이딩은 다형성(polymorphism)을 구현하는 데 중요한 역할을 합니다. 다형성이란, 같은 이름의 메소드가 다른 동작을 하는 것을 의미합니다. 즉, 부모 클래스와 자식 클래스에서 같은 이름의 메소드가 있더라도, 자식 클래스에서 오버라이딩한 경우 자식 클래스의 메소드가 실행됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> 부모클래스 <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">void</span> 메소드이름<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// ...</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> 자식클래스 <span class=\"token keyword\">extends</span> 부모클래스 <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">void</span> 메소드이름<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 부모 클래스의 메소드를 재정의</span>\n        <span class=\"token comment\">// ...</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n  <aside>\n  ➕ 오버로딩(overloading)과 오버라이딩(overriding)은 다른 개념입니다. 오버로딩은 같은 이름의 메소드를 매개변수의 개수나 타입을 다르게 정의하는 것을 의미합니다.\n  </aside>\n</li>\n<li>\n<p>super</p>\n<p>super는 자식 클래스에서 부모 클래스의 멤버를 호출할 때 사용하는 키워드입니다. 부모 클래스의 생성자나 메소드를 호출할 때 사용할 수 있습니다.</p>\n<p>super()는 부모 클래스의 생성자를 호출하며, 반드시 자식 클래스 생성자의 첫 줄에서 호출되어야 합니다. 만약 super()를 호출하지 않으면, 자동으로 부모 클래스의 기본 생성자가 호출됩니다.</p>\n<p>super.멤버이름은 부모 클래스의 멤버를 호출할 때 사용합니다. 만약 자식 클래스에서 부모 클래스와 동일한 이름의 멤버를 정의하였다면, super.멤버이름을 사용하여 부모 클래스의 멤버를 호출할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> 부모클래스 <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">void</span> 메소드이름<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// ...</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> 자식클래스 <span class=\"token keyword\">extends</span> 부모클래스 <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">void</span> 메소드이름<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span>메소드이름<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 부모 클래스의 메소드 호출</span>\n        <span class=\"token comment\">// 자식 클래스에서 메소드를 구현</span>\n        <span class=\"token comment\">// ...</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ul>","tableOfContents":"","frontmatter":{"title":"프로그래밍 기초 10","date":"June 09, 2023","description":"상속, 오버라이딩","tags":["개발","프로그래밍 기초","객체지향"]}},"previous":{"fields":{"slug":"/programming-basics/index0608/"},"frontmatter":{"title":"프로그래밍 기초 9"}},"next":{"fields":{"slug":"/programming-basics/index0612/"},"frontmatter":{"title":"프로그래밍 기초 11"}}},"pageContext":{"id":"661b6951-f5a7-5815-82e2-ca1d1430815e","previousPostId":"5d25f01c-2e71-5729-adce-2366de4b810c","nextPostId":"2621eaeb-2f69-5b3d-b3b9-7aa8de1442f7"}},"staticQueryHashes":["3000541721","3274528899"],"slicesMap":{}}